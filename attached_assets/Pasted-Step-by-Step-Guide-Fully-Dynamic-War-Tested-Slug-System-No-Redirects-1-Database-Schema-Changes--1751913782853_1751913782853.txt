Step-by-Step Guide: Fully Dynamic, War-Tested Slug System (No Redirects)
1. Database Schema Changes
a. Add slug Field to Exams Table
Add a slug column to your exams table if not present:

sql
Copy
Edit
ALTER TABLE exams ADD COLUMN IF NOT EXISTS slug VARCHAR(255) UNIQUE NOT NULL;
Add an index for fast lookups:

sql
Copy
Edit
CREATE UNIQUE INDEX IF NOT EXISTS idx_exams_slug ON exams(slug);
b. Enforce Uniqueness and Consistency
Add a database-level unique constraint so no two exams share a slug.

2. Slug Generation Utility
a. Write a Robust Slugification Function
Ensure it:

Lowercases the title

Replaces spaces and special chars with hyphens

Removes all non-URL-safe characters

Handles duplicate slugs by appending a suffix or exam ID if needed

Example (JS/Node):

js
Copy
Edit
function slugify(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '')   // Remove invalid chars
    .replace(/\s+/g, '-')           // Replace spaces with hyphens
    .replace(/-+/g, '-')            // Collapse multiple hyphens
    .replace(/^-+|-+$/g, '');       // Trim hyphens
}

// Usage: append "-ID" if duplicate found
async function ensureUniqueSlug(baseSlug, examId = null) {
  let slug = baseSlug;
  let count = 1;
  while (await slugExists(slug, examId)) {
    slug = `${baseSlug}-${++count}`;
  }
  return slug;
}
3. Database Logic: Always Query by Slug
All lookups, routes, and links must use the exam’s slug as the unique key.

Never use numeric IDs in URLs or queries for exam routes.

Remove/disable any fallback for ID-based lookups (do not serve /exam/2).

4. Slug Lifecycle Management
a. On Exam Creation:
Auto-generate and save the slug using the slugify function.

Check and enforce uniqueness.

b. On Exam Title Update:
Regenerate the slug using the new title.

Check for uniqueness before updating.

Update the slug in the database.

c. On Admin UI/List/Link Generation:
Always use the current slug field for links and lookups.

d. Legacy Cleanup:
Run a migration to generate and save slugs for all existing exams (using titles).

Remove any existing routes or references that use numeric IDs.

5. Frontend: Universal Slug Usage
a. Routing:
Define routes using slugs only (e.g., /exam/:slug).

Fetch the exam by slug (e.g., /api/exams/:slug).

b. UI and Navigation:
All internal links, buttons, and cards use slug, never ID.

c. Dynamic Updates:
If an exam title changes and thus the slug changes, all links, breadcrumbs, and references auto-update.

Optionally, update any client-side state/store/cache to use the new slug.

6. Admin Panel and CRUD UIs
Display the generated slug in the UI for review (editable only if you allow).

Show validation feedback if a duplicate slug would be created.

On title edit, update the slug and propagate everywhere.

7. QA and Testing
Test with titles containing spaces, symbols, non-English chars, and edge cases (very long, duplicate).

Ensure exam cards and URLs all use the latest slug.

Confirm no /exam/:id routes work—404 if accessed directly.

Changing a title immediately changes the slug everywhere—no redirects.

Test for broken links and uniqueness collisions.

Verify all exam lookups, API responses, and UI state rely solely on the slug.

8. (Optional but Recommended) Programmatic Migration Script
Run once to generate and store slugs for all existing exams, filling in slugs for legacy entries.

Example (Pseudo-code):

js
Copy
Edit
const exams = await db.query('SELECT id, title FROM exams');
for (const exam of exams) {
  let slug = slugify(exam.title);
  slug = await ensureUniqueSlug(slug, exam.id);
  await db.query('UPDATE exams SET slug=$1 WHERE id=$2', [slug, exam.id]);
}
9. SEO & Sitemap
Regenerate sitemap.xml using new slug-based URLs.

All canonical links and SEO meta tags should use the slug URL.

10. Remove Legacy Fallbacks
Delete any backend or frontend code that allows old numeric-ID-based exam access.

Remove any logic that attempts to redirect numeric slugs—404 if route doesn’t match a slug.

